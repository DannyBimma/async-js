// API URL change - https://restcountries.com/v2/

Asynchronous JavaScript:
Normally, a given program's code runs straight along, with only one thing happening at once. If a function relies on the result of another function, it has to wait for the other function to finish and return, and until that happens, the entire program is essentially stopped from the perspective of the user.

Mac users, for example, sometimes experience this as the spinning rainbow-colored cursor (or "beachball" as it is often called). This cursor is how the operating system says "the current program you're using has had to stop and wait for something to finish up, and it's taking so long that I was worried you'd wonder what was going on."

This is a frustrating experience and isn't a good use of computer processing power â€” especially in an era in which computers have multiple processor cores available. There's no sense sitting there waiting for something when you could let the other task chug along on another processor core and let you know when it's done. This lets you get other work done in the meantime, which is the basis of asynchronous programming. It is up to the programming environment you are using (web browsers, in the case of web development) to provide you with APIs that allow you to run such tasks asynchronously. 
Asynchronous techniques are very useful, particularly in web programming. When a web app runs in a browser and it executes an intensive chunk of code without returning control to the browser, the browser can appear to be frozen. This is called blocking; the browser is blocked from continuing to handle user input and perform other tasks until the web app returns control of the processor.

AJAX Calls:
JavaScript has multiple ways of making AJAX calls, and one of the most old school ways is through the XML-HTTP-Request function. It works by basically storing the result of the function call into a variable. Next, you will need the URL to which you will be making the AJAX call. This is done by calling the open method on the object created by the XML-HTTP-Request function. The open method then accepts two parameters, the first is the type of request, and the second is a string containing the URL to which the AJAX call is to be made. The string containing the AJAX call URL is also known as the API endpoint. After that the request just need to be sent by calling the send method on the object created by the XML-HTTP-Request function.

Avoiding Callback Hell:
When making multiple AJAX calls, the asynchronous nature of them will require certain steps to be taken in order to control the way the data is received back from the server. Since it happens asynchronously there's no telling which request will come back first in a series of request. But there's a way to create a sequence of AJAX calls so the second one only runs once the first one has finished. One way to do this is be nesting event listeners, meaning each new event listener will have to wait for the load event to complete before executing their code and moving on to the next one. Implementing a sequence of AJAX calls like this can be essential to the proper running of your program if data needed from one AJAX call is dependant on data coming from another. The major problem is, the more AJAX calls you have to make this way, the deeper your nested event listeners will go. This will inevitably lead to what's know as call back hell. And to avoid it, you'll need to help of promises. 

Promises and The Fetch API:
A Promise is a proxy for a value not necessarily known when the promise is created. Or to put it more simply, a promise is just a place holder for a future result (like the data coming in from an AJAX call). It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.

A Promise is in one of these states:

    pending: initial state, neither fulfilled nor rejected.
    fulfilled: meaning that the operation was completed successfully.
    rejected: meaning that the operation failed.

A pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options happens, the associated handlers queued up by a promise's then method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached. One of the biggest benefits to using promises instead of XML-HTTP-Requests, is no longer needing to rely on events and callbacks passed into asynchronous functions to handle asynchronous results. Another reason is the fact that events and callbacks often times cause unexpected results. Big the biggest advantage of all is the ability to chain promises for a sequence of asynchronous operations, this is how you avoid callback hell.

Chaining Promises:
The methods promise.then(), promise.catch(), and promise.finally() are used to associate further action with a promise that becomes settled.
The .then() method takes up to two arguments; the first argument is a callback function for the resolved case of the promise, and the second argument is a callback function for the rejected case. Each .then() returns a newly generated promise object, which can optionally be used for chaining.